package notifier

import (
	"context"
	"crypto/tls"
	"fmt"
	"net"
	"net/smtp"
	"strings"
	"time"
)

// EmailNotifier sends alerts via email
type EmailNotifier struct {
	smtpHost   string
	smtpPort   int
	from       string
	to         []string
	username   string
	password   string
	useTLS     bool
	skipVerify bool
}

// EmailConfig holds configuration for EmailNotifier
type EmailConfig struct {
	SMTPHost   string
	SMTPPort   int
	From       string
	To         []string
	Username   string
	Password   string
	UseTLS     bool
	SkipVerify bool // Skip TLS certificate verification (not recommended for production)
}

// NewEmailNotifier creates a new email notifier
func NewEmailNotifier(config EmailConfig) *EmailNotifier {
	if config.SMTPPort == 0 {
		config.SMTPPort = 587
	}

	return &EmailNotifier{
		smtpHost:   config.SMTPHost,
		smtpPort:   config.SMTPPort,
		from:       config.From,
		to:         config.To,
		username:   config.Username,
		password:   config.Password,
		useTLS:     config.UseTLS,
		skipVerify: config.SkipVerify,
	}
}

// Type returns the notifier type
func (e *EmailNotifier) Type() string {
	return "email"
}

// Validate checks if the configuration is valid
func (e *EmailNotifier) Validate() error {
	if e.smtpHost == "" {
		return fmt.Errorf("SMTP host is required")
	}
	if e.from == "" {
		return fmt.Errorf("from address is required")
	}
	if len(e.to) == 0 {
		return fmt.Errorf("at least one recipient is required")
	}
	return nil
}

// Send sends an alert via email
func (e *EmailNotifier) Send(ctx context.Context, alert *Alert) error {
	subject := e.buildSubject(alert)
	body := e.buildBody(alert)

	message := e.buildMessage(subject, body)

	return e.sendMail(ctx, message)
}

// buildSubject builds the email subject
func (e *EmailNotifier) buildSubject(alert *Alert) string {
	severityPrefix := strings.ToUpper(alert.Severity)
	patternName := alert.PatternName
	if alert.PatternDisplayName != "" {
		patternName = alert.PatternDisplayName
	}
	return fmt.Sprintf("[%s] PII Detected: %s in %s", severityPrefix, patternName, alert.Namespace)
}

// buildBody builds the email body
func (e *EmailNotifier) buildBody(alert *Alert) string {
	var sb strings.Builder

	sb.WriteString("PII Detection Alert\n")
	sb.WriteString("====================\n\n")

	sb.WriteString(fmt.Sprintf("Severity: %s\n", strings.ToUpper(alert.Severity)))
	sb.WriteString(fmt.Sprintf("Pattern: %s\n", alert.PatternName))

	if alert.PatternDisplayName != "" {
		sb.WriteString(fmt.Sprintf("Pattern Display Name: %s\n", alert.PatternDisplayName))
	}

	sb.WriteString(fmt.Sprintf("Namespace: %s\n", alert.Namespace))

	if alert.Pod != "" {
		sb.WriteString(fmt.Sprintf("Pod: %s\n", alert.Pod))
	}

	if alert.Container != "" {
		sb.WriteString(fmt.Sprintf("Container: %s\n", alert.Container))
	}

	if alert.PolicyName != "" {
		sb.WriteString(fmt.Sprintf("Policy: %s\n", alert.PolicyName))
	}

	sb.WriteString(fmt.Sprintf("Match Count: %d\n", alert.MatchCount))

	if alert.Source != "" {
		sb.WriteString(fmt.Sprintf("Source: %s\n", alert.Source))
	}

	sb.WriteString(fmt.Sprintf("Timestamp: %s\n", alert.Timestamp.Format(time.RFC3339)))

	sb.WriteString("\nMessage:\n")
	sb.WriteString(alert.Message)
	sb.WriteString("\n\n")

	if len(alert.Labels) > 0 {
		sb.WriteString("Labels:\n")
		for k, v := range alert.Labels {
			sb.WriteString(fmt.Sprintf("  %s: %s\n", k, v))
		}
	}

	sb.WriteString("\n--\n")
	sb.WriteString("This alert was generated by PII Redactor\n")

	return sb.String()
}

// buildMessage builds the complete email message with headers
func (e *EmailNotifier) buildMessage(subject, body string) []byte {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("From: %s\r\n", e.from))
	sb.WriteString(fmt.Sprintf("To: %s\r\n", strings.Join(e.to, ",")))
	sb.WriteString(fmt.Sprintf("Subject: %s\r\n", subject))
	sb.WriteString("MIME-Version: 1.0\r\n")
	sb.WriteString("Content-Type: text/plain; charset=utf-8\r\n")
	sb.WriteString("\r\n")
	sb.WriteString(body)

	return []byte(sb.String())
}

// sendMail sends the email
func (e *EmailNotifier) sendMail(ctx context.Context, message []byte) error {
	addr := fmt.Sprintf("%s:%d", e.smtpHost, e.smtpPort)

	// Create connection with timeout from context
	var conn net.Conn
	var err error

	dialer := &net.Dialer{
		Timeout: 30 * time.Second,
	}

	if e.useTLS {
		tlsConfig := &tls.Config{
			ServerName:         e.smtpHost,
			InsecureSkipVerify: e.skipVerify,
		}
		conn, err = tls.DialWithDialer(dialer, "tcp", addr, tlsConfig)
	} else {
		conn, err = dialer.DialContext(ctx, "tcp", addr)
	}

	if err != nil {
		return fmt.Errorf("failed to connect to SMTP server: %w", err)
	}
	defer conn.Close()

	client, err := smtp.NewClient(conn, e.smtpHost)
	if err != nil {
		return fmt.Errorf("failed to create SMTP client: %w", err)
	}
	defer client.Close()

	// STARTTLS if not already using TLS
	if !e.useTLS {
		if ok, _ := client.Extension("STARTTLS"); ok {
			tlsConfig := &tls.Config{
				ServerName:         e.smtpHost,
				InsecureSkipVerify: e.skipVerify,
			}
			if err := client.StartTLS(tlsConfig); err != nil {
				return fmt.Errorf("failed to start TLS: %w", err)
			}
		}
	}

	// Authenticate if credentials provided
	if e.username != "" && e.password != "" {
		auth := smtp.PlainAuth("", e.username, e.password, e.smtpHost)
		if err := client.Auth(auth); err != nil {
			return fmt.Errorf("SMTP authentication failed: %w", err)
		}
	}

	// Set sender
	if err := client.Mail(e.from); err != nil {
		return fmt.Errorf("failed to set sender: %w", err)
	}

	// Set recipients
	for _, recipient := range e.to {
		if err := client.Rcpt(recipient); err != nil {
			return fmt.Errorf("failed to set recipient %s: %w", recipient, err)
		}
	}

	// Send message body
	w, err := client.Data()
	if err != nil {
		return fmt.Errorf("failed to get data writer: %w", err)
	}

	_, err = w.Write(message)
	if err != nil {
		return fmt.Errorf("failed to write message: %w", err)
	}

	err = w.Close()
	if err != nil {
		return fmt.Errorf("failed to close data writer: %w", err)
	}

	return client.Quit()
}
